# 07. 네트워크 심화

### <mark style="color:blue;">07-1 안정성(Stability)을 위한 기술</mark>

#### ⭐ 가용성

*   **안전성**

    * 특정 기능을 언제든 균일한 성능으로 수행할 수 있는 특성


* **가용성**
  *   **컴퓨터 시스템이 특정 기능을 실제로 수행할 수 있는 시간의 비율**

      ![](<../../.gitbook/assets/image (6).png>)



* **결함 감내**
  * 문제가 발생하더라도 가능할 수 있는 능력



#### ⭐ 이중화, 다중화

*   **이중화**

    * 무언가를 이중으로 두는 기술, 예비(백업)을 마련하는 방법.


* **단일 장애점(SPoF: Single Point Of Failure)**
  *   문제가 발생할 경우 시스템 전체가 중단될 수 있는 대상

      ![](<../../.gitbook/assets/image 1 (6).png>)



* **이중화 구성 방식** (액티브는 가동 상태를 의미하며, 스텐바이는 액티브의 백업으로서 대기하는 상태를 의미)
  * **액티브/스탠바디(active-standby)**
    * 액티브 상태인 시스템에 문제가 발생하면 스탠바이 시스템이 자동으로 대신하여 동작
    * 성능상의 큰 변화를 기대하기는 어려움
  *   **액티브/액티브(active-active)**

      * 성능상의 이점이 있음. 하지만,
      * 한 시스템에 문제가 발생하면 순간적으로 다른 시스템에 부하가 급증할 수 있으며, 이로 인해 추가적인 문제가 발생할 수 있음.


* **다중화**
  * 무언가를 여러 개 두는 기술
  * **티밍(teaming), 본딩(bonding)**
    * 여러 개의 네트워크 인터페이스(NIC)를 이중화/다중화하여 마치 더 뛰어나고 안정적인 성능을 보유한 하나의 인터페이스처럼 보이게 하는 기술



#### ⭐ 로드 벨런싱

*   **트래픽(traffic)**

    * **주어신 시점에 네트워크를 경유한 데이터의 양 → 주어진 시점에 특정 노드를 경유한 패킷의 양**


*   **로드 밸런싱(load balancing)**

    * 로드 벨런서를 통해 부하를 분산하는 방법


* **로드 밸런서(load balancer)**
  * L4, L7 스위치 장비로도 할 수 있고, 소프트웨어로도 할 수 있음.
  *   대표적인 웹 서버 소프트웨어인 Nginx에도 로드 밸런싱 기능이 내포되어 있음

      ![](<../../.gitbook/assets/image 2 (6).png>)



{% hint style="success" %}
#### 💡서버의 상태를 검사하는 헬스 체크

* **헬스 체크**
  * 다중화된 서버 환경에서는 현제 문제가 있는 서버는 없는지, 현재 요청에 대해 올바른 응답을 할 수 있는 상태인지를 **주기적으로 검사**함
  * 헬스 체크는 주로 **로드 밸런서**에 의해 이루어 지는 경우가 많으며, HTTP, ICMP등 다양한 프로토콜을 활용할 수 있음.



* **하트비트**
  * 이외에도 하트비트(heartbeat)라는 메시지를 주기적으로 주고받는 방법도 있음.
  * 신호가 끊겼을 때 문제 발생을 감지하는 방법
{% endhint %}



*   **로드 밸런싱 알고리즘**

    * **라운드 로빈 알고리즘**
      *   단순히 서버를 돌아가며 부하를 전달

          ![](<../../.gitbook/assets/image 3 (6).png>)
      *   서버마다 **가중치를 부여**하는 **가중치 라운드 로빈 알고리즘**이 있음.

          ![](<../../.gitbook/assets/image 4 (6).png>)
    * **최소 연결 알고리즘**
      * 연결이 적은 서버부터 우선적으로 부하를 전달
      * 서버마다 **가중치를 부여**하는 **가중치 최소 연결 알고리즘**이 있음.
    * 단순히 무작위로 고르기도 하고, 해시를 이용하거나 응답 시간이 가장 짧은 서버를 선택하기도 함.



{% hint style="success" %}
#### 💡참조 1. 포워드 브록시와 리버스 프록시

*   **오리진 서버(origin server)**

    * 자원을 생성하고 클라이언트에게 권한 있는 응답을 보낼 수 있는 HTTP 서버


* **포워드 프록시** (프록시)
  * **클라이언트가 선택한** 메시지 전달 대리자. 어떤 프록시를 어떻게 사용할지는 클라이언트가 선택함.
  *   캐시 저장, 클라이언트 암호화 및 접근 제한 등의 기능을 제공

      ![](<../../.gitbook/assets/image 5 (6).png>)



* **리버스 프록시** (**게이트웨이** 라고도 불림)
  * 아웃바운드 연결에 대해 **오리진 서버 역할**을 하지만, 수신된 요청을 변환하여 **다른 인바운드 서버(들)로 전달하는 중개자** 역할
  *   캐시를 저장할 수 있고, 로드 밸런서로 동작할 수 있음.

      ![](<../../.gitbook/assets/image 6 (6).png>)
{% endhint %}

***

### <mark style="color:blue;">07-2 안전성(Safety)을 위한 기술</mark>

#### ⭐ 암호와 인증서

*   **세션키**

    * 대칭 키를 상대에게 안전하게 전달하기 위해 **공개 키**로 **대칭 키를 암호화**하고, **개인 키**로 **암호화된 대칭 키를 복호화**할 수 있음.
    * 이렇게 하면 **대칭 키를 안전하게 공유**함과 동시에 공유한 대칭 키를 이용해 **빠르게 암호화/복호화를 수행**함.


* **인증서와 디지털 서명**
  * **공개키 인증서**
    * 공개 키와 공개 키의 유효성을 입증하기 위한 전자 문서
  * **인증 기관 (CA: Certification Authority)**
    *   인증서의 발급, 검증, 저장과 같은 역할을 수행할 수 있는 공인 기관.

        ![](<../../.gitbook/assets/image 7 (4).png>)
    *   서명 값은 **1.** 인증서 내용에 대한 해시 값을 **2.** CA의 개인 키로 암호화 하는 방식으로 만들어 짐.

        ![](<../../.gitbook/assets/image 8 (4).png>)
    * 서명 값을 CA의 공개키로 복호한 값과 인증서를 해시 함수를 통해 얻은 해시 값을 비교하여 확인할 수 있다.
    *   이러한 절차를 **디지털 서명(digital signature)**&#xC774;라 함.

        ![](<../../.gitbook/assets/image 9 (4).png>)



#### ⭐ HTTPS: SSL과 TLS

TLS는 SSL을 계승 프로토콜이며, 요즘에는 TLS 1.3이 주로 사용됨. 대표적인 프로토콜로 **HTTPS**가 있음.

* **HTTPS**
  * HTTP 메시지의 안전한 송수신을 위해 개발된 프로토콜로, 다음과 같은 단계를 거쳐 송수신됨.
    1. TCP Three-way handshake
    2. **TLS handshake**
    3. 암호화된 메시지 송수신
  *   **TLS handshake**

      ![](<../../.gitbook/assets/image 10 (4).png>)

      * **ClientHello**
        * 암호화된 통신을 위해 서로 맞춰 봐야 할 정보들을 제시하는 메시지
        * 지원되는 TLS 버전, 사용 가능한 암호화 방식과 해시 함수, 키를 만들기 위해 사용할 클라이언트의 난수 등이 포함되어 있음.
        *   사용 가능한 암호화 방식과 해시 함수를 담을 정보를 **암호 스위트(cipher suite)**&#xB77C; 함.

            ![](<../../.gitbook/assets/image 11 (4).png>)
      * **ServerHello**
        * 제시된 정보들을 선택하는 메시지
        * 선택된 TLS 버전, 암호 스위트 등의 정보, 키를 반들기 위해 사용할 서버의 난수 등이 포함되어 있음.
      * **키 교환**
        * 이러한 메시지를 주고받으면 암호화된 통신을 위해 사전 협의해야 할 정보들이 결정됨.
        * 이렇게 결정된 정보를 토대로 서버와 클라이언트는 암호화에 사용할 키를 만들어낼 수 있음.
        *   이 단계 이후부터 클라이언트와 서버는 키로 암호화된 암호문을 주고받을 수 있게 됨.

            ![](<../../.gitbook/assets/image 12 (4).png>)
      * **Certificate** 메시지와 **CertificateVerify** 메시지를 전송함. 이는 각각 인증서와 검증을 위한 디지털 서명을 의미함.
      * 클라이언트는 이 메시지를 토대로 서버의 공개 키를 검증하게 됨.
      * 이어서 서버와 클라이언트는 TLS handshake의 마지막을 의미하는 **FInished** 메시지를 주고 받음.
      *   **Finished** 메시지와 함께 암호화된 메시지(Application Data)를 전송할 수 있음.

          ![](<../../.gitbook/assets/image 13 (4).png>)

***

### <mark style="color:blue;">07-3 무선 네트워크</mark>

#### ⭐ 와이파이와 802.11

오늘날 LAN 환경에서 무선 통신은 **IEEE 802.11로 표준화**되어 있음.

* **와이파이**
  * IEEE 802.11 표준을 따르는 무선 LAN 기술



#### ⭐ AP와 서비스 셋

*   **AP(Access Point)**

    * 무선 통신 기기들을 연결하며 무선 네트워크를 구성하는 장치


*   **Infrastructure mode**

    * 무선 LAN의 기기들은 AP를 경유해 인터넷에 접속하거나 서로 메시지를 주고받을 수 있음.
    * 이렇게 AP를 경유하여 통신이 이루어지는 무선 네트워크 통신 방식을 **Infrastructure mode**라 함.


* **서비스 셋(Service Set)**
  *   무선 네트워크를 이루는 AP와 여러 장치들의 집합

      ![](<../../.gitbook/assets/image 14 (4).png>)



* **SSID**
  *   서비스 셋을 식별하기 위한 ID

      ![](<../../.gitbook/assets/image 15 (4).png>)



* **비컨 프레임(beacon frame)**
  * AP가 불특정 다수 모두에게 **주기적으로 자신을 알리는** **브로드캐스트 메시지**
  *   장치에 와이파이 목록이 뜨는 것은 장치가 AP로부터 비컨 프레임을 받았기 때문

      ![](<../../.gitbook/assets/image 16 (3).png>)



***
