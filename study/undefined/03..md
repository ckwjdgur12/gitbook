# 03. 네트워크 계층

<mark style="color:blue;">03-1 LAN을 넘어서는 네트워크 계층</mark>

LAN을 넘어 다른 네트워크와 통신하기 위해서는 **네트워크 계층**의 역할이 필수.

#### ⭐ 데이터 링크 계층의 한계 <a href="#id-1b4aa93c-3977-8100-a38f-c6e30f70acec" id="id-1b4aa93c-3977-8100-a38f-c6e30f70acec"></a>

물리 계층과 데이터 링크 계층만으로 LAN을 넘어서 통신하기 어렵다. 대표적으로 2가지 이유가 있다.

1.  물리 계층과 데이터 링크 계층만으로는 **다른 네트워크까지의 도달 경로를 파악하기 어렵다.**

    * 통신을 빠르게 주고 받으려면 최적의 경로로 패킷이 이동해야 하는데, 이 것을 결정하는 것을 **라우팅(routing)**&#xC774;라고 한다.
    * 이 라우팅을 수행하는 **네트워크 계층의 대표적인 장비**로 **라우터(router)**&#xAC00; 있다. (03-3에 자세히 있음)

    <figure><img src="../../.gitbook/assets/image (1).png" alt="" width="563"><figcaption></figcaption></figure>
2.  MAC 주소만으로는 모든 네트워크에 속한 호스트의 위치를 특정하기 어렵다.

    * 택배의 수신인 역할을 하는 정보가 MAC 주소라면, 수신지 역할을 하는 정보는 네트워크 계층의 **IP 주소**이다
    * 네트워크에서도 **MAC주소**와 **IP주소**를 함께 사용하고, 기본적으로 IP주소를 우선으로 활용한다.

    <figure><img src="../../.gitbook/assets/image 1 (1).png" alt="" width="375"><figcaption></figcaption></figure>

    * MAC주소를 물리 주소라고 부르는 것처럼 **IP 주소**는 **논리 주소**라고도 부른다.
    * IP 주소는 호스트에 직접 할당이 가능하다.
    * **DHCP**라는 프로토콜을 통해 자동으로 할당 받거나, 사용자가 직접 할당할 수 있고, 한 호스트가 복수의 IP 주소를 가질 수도 있다. (03-2에 자세히 있음)

{% hint style="success" %}
📌 **네트워크 계층이 다른 네트워크와의 통신을 가능하게 하고,** 이는 **IP 주소를 이용해 수신지 주소를 설정**하거나, **해당 수신지 까지의 최적의 경로를 경정하는 라우팅**이 **네트워크 계층에서 이루어지기 때문이다!**
{% endhint %}



#### ⭐ 인터넷 프로토콜(Internet Protocol, IP) <a href="#id-1b5aa93c-3977-80cb-aece-df69ce65d730" id="id-1b5aa93c-3977-80cb-aece-df69ce65d730"></a>

*   **IP 주소 형태**

    * 4바이트로 표현, 네 개의 10진수로 표기.
    * **192.168.1.1**


* **IP의 기능**
  * IP의 대표적인 두 가지 기능으로, **IP 주소 지정**과 **IP 단편화**가 있다.
  * **IP 주소 지정(IP addressing)**
    * IP 주소를 바탕으로 송수신 대상을 지정하는 것.
  *   **IP 단편화 (IP fragmentatin)**

      * 전송하고자 하는 패킷의 크기가 MTU라는 최대 전송 단위보다 클 경우, 이를 MTU 크기 이하의 복수의 패킷으로 나누는 것.


*   **MTU(Maximum Transmission Unit)**

    * 한 번에 전송 가능한 IP 패킷의 최대 크기
    * 일반적으로 1500바이트 이며(IP 패킷의 헤더 포함), MTU 크기 이하로 나누어진 패킷은 수신지에 도착하면 다시 재조립됨.

    <figure><img src="../../.gitbook/assets/image 2 (1).png" alt="" width="563"><figcaption></figcaption></figure>


*   **IPv4**

    <figure><img src="../../.gitbook/assets/image 3 (1).png" alt=" " width="563"><figcaption></figcaption></figure>

    * **프레임**의 **페이로드**로 **데이터 필드에 명시**됨.
    * **식별자, 플래그, 단편화 오프셋** 필드는 I**P 단편화 기능**에 관여하고, **송신지 IP 주소, 수신지 IP 주소**는 **IP 주소 지정** **기능**에 관여함.
    * 핵심이 되는 부분은 1. **식별자**, 2. **플래그**, 3 **단편화 오프셋**, 4. **TTL**, 5. **프로토콜**, 6. **송신지 IP 주소**, 7. **수신지 IP 주소.**

    <figure><img src="../../.gitbook/assets/image 4 (1).png" alt="" width="563"><figcaption></figcaption></figure>

    * **식별자(Identifier)**
      * **패킷에 할당된 번호.**
      * 만일 패킷이 여러 조각으로 쪼개져서 전송되었따면, 수신지에서는 이들을 재조합해야함. 이때 **어떤 메시지에서부터 쪼개졌는지를 인식하기 위해 식별자를 사용.**
    *   **플래그(Flag)**

        * 총 3개의 비트로 구성되어 있음

        <figure><img src="../../.gitbook/assets/image 5 (1).png" alt=""><figcaption></figcaption></figure>

        * 첫 번째 비트는 항상 0으로, 예약된 비트로 현재 사용되지 않음.
        * **DF(Don’t Fragment)**
          * IP 단편화를 수행하지 말라는 표시
        * **MF(More Fragment)**
          * 단편화된 패킷이 더 있는지를 나타냄. 0이라면 이 패킷이 마지막 패킷임을 의미.
    *   **단편화 오프셋(Fragment offset)**

        * 단편화되어 전송되는 패킷들은 수신지에 순서대로 도착하지 않을 수 있음.
        * **패킷들을 순서대로 재조합**하기 위해 단편화 되기 전 **초기 데이터에서 몇 번째 데이터에 해당하는 패킷인지를 나타냄.**

        <figure><img src="../../.gitbook/assets/image 6 (1).png" alt="" width="563"><figcaption></figcaption></figure>
    * **TTL(Time To Live)**
      * 패킷의 수명을 의미함
      * 패킷이 라우터를 거칠 때마다 TTL이 1씩 감소하며, TTL 값이 0으로 떨어진 패킷은 폐기됨. (폐기가 되었다는 메시지를 전송해주는 프로토콜은 **ICMP**로, **4장**에 나옴)
      * 패킷이 호스트 또는 라우터에 한 번 전달되는 것을 **홉(Hop)**&#xC774;라고 함.
      * **무의미한 패킷이 네트워크상에 지속적으로 남아있는 것을 방지하기 위함.**
    * **프로토콜**
      * 상위 계층의 프로토콜이 무엇인지를 나타냄.
      * 대표적으로 TCP는 6번, UDP는 17번임.
    * **송신지 IP 주소와 7.** **수신지 IP 주소**
      * 송수신지의 IPv4 주소를 알 수 있음.

{% hint style="success" %}
📌 요약하면, IPv4는 **식별자, 플래그, 단편화 오프셋**으로 **단편화와 재조합**을 할 수 있고, **프로토콜 필드**로 **상위 계층 프로토콜을 알 수 있으며, TTL**로 **남은 패킷의 수명을 파악**할 수 있음. 또한, **송신지 IP주소, 수신지 IP 주소를 통해 IP 주소를 지정**할 수 있음.
{% endhint %}



* **IPv6**
  * 약 43억 개의 IPv4의 주소의 총량이 부족하여 IPv6가 나옴.
  * 16바이트로 주소를 표현, 8개 그룹의 16진수로 표기.
  *   **IPv6의 기본 헤더**는 **IPv4에 비해 간소화** 되어 있으며, 핵심이 되는 부분은 **1. 다음 헤더**, **2. 홉 제한, 3 송신지 IP 주소, 4. 수신지 IP 주소.**

      ![](<../../.gitbook/assets/image 7 (1).png>)

      1. **다음 헤더 (Next header)**
         * 상위 계층의 프로토콜을 가리키거나 확장 헤더를 가리킴.
         *   IPv6의 헤더는 **기본 헤더**이지만, **추가적인 헤더 정보가 필요할 경우**에는 기본 헤더와 더불어 **확장 헤더(Extention header)**&#xB77C;는 추가 헤더를 가질 수 있음.

             ![](<../../.gitbook/assets/image 8 (1).png>)
         *   단편화 관련 필드가 없고, **단편화 확장 헤더**를 통해 단편화가 이루어짐

             <figure><img src="../../.gitbook/assets/image 9 (1).png" alt=" "><figcaption></figcaption></figure>

             * **단편화 오프셋, M**(IPv4에서는 MF)**, 식별자**는 IPv4와 같은 역할을 수행.
      2. **홉 제한**
         * IPv4의 **TTL**처럼 **패킷의 수명**을 나타냄.
      3. **송신지 IP 주소**, 4. **수신지 IP 주소**
         * IPv6의 **주소 지정이 가능.**
  * **IPv4헤더 길이는 가변적**이고, **IPv6 기본 헤더는** 40바이트로 **고정적**이다.

{% hint style="success" %}
**📌 아직까지는 IPv4가 많이 사용됨.**
{% endhint %}



#### ⭐ ARP(Address Resolution Protocol) <a href="#id-1b5aa93c-3977-8081-a5e2-d39c92a49e71" id="id-1b5aa93c-3977-8081-a5e2-d39c92a49e71"></a>

**상대 호스트의 IP 주소는 알지만, MAC 주소는 알지 못하는 상황**에 **ARP 프로토콜을 사용**함.

* **ARP**
  * IP 주소를 통해 MAC 주소를 알아내는 프로토콜.
  * ARP를 통해 **동일 네트워크 내**에 있는 **호스트의 IP 주소를 통해 MAC 주소를 알아낼 수 있음.**
  * **1. ARP 요청, 2. ARP 응답, 3. ARP 테이블 갱신** 3단계로 이루어 짐.
  * **ARP 요청**
    *   **A**는 네트워크 내의 모든 호스트에게 브로드캐스트 메시지를 보냄. 이 메시지는 **ARP 요청**이라는 **ARP 패킷**임.

        ![](<../../.gitbook/assets/image 10 (1).png>)
  * **ARP 응답**
    * 모든 호스트가 ARP 요청 메시지를 수신하지만, **B**를 제외한 나머지 호스트는 자신의 IP 주소가 아니므로 이를 무시함.
    *   **B**는 자신의 MAC 주소를 담은 메시지를 A에게 전송함. 이 유니케스트 메시지는 **ARP 응답** 이라는 **ARP 패킷**임.

        ![](<../../.gitbook/assets/image 11 (1).png>)
    * 이를 통해 **A**는 **B**의 MAC 주소를 알게됨.
  * **ARP 테이블 갱신**
    * **ARP 테이블**은 **IP 주소와 그에 맞는 MAC 주소 테이블을 대응하는 표**
    *   1, 2 단계를 통해 **B**의 MAC 주소를 알게 되면, **B**의 IP 주소와 MAC 주소의 연관 관계를 ARP 테이블에 추가함.

        ![](<../../.gitbook/assets/image 12 (1).png>)
    * 여기까지 이루어 지면, 앞으로 A는 B와 통신할 때 굳이 브로드캐스트 ARP 요청을 보낼 필요가 없어짐.
  *   **ARP 패킷**

      *   프레임의 페이로드에 포함되어 전송됨.

          ![](<../../.gitbook/assets/image 13 (1).png>)
      * 오퍼레이션 코드: ARP 패킷의 유형(요청, 응답)
      * 송수진지 하드웨어 주소: MAC 주소


* 호스트 **A**와 **B**가 **서로 다른 네트워크**에 속해 있는 경우
  *   **라우터 A**의 **MAC 주소를 모른다면, ARP 요청 - ARP 응답 과정**을 통해 **라우터 A**의 **주소를 얻어** **와서 이를 향해 패킷을 전송**

      ![](<../../.gitbook/assets/image 14 (1).png>)
  *   **라우터 A**와 **라우터 B**의 MAC 주소를 모른다면 한번 더 같은 과정을 라우터 A에서 시도.

      ![](<../../.gitbook/assets/image 15 (1).png>)
  *   **라우터 B**와 **호스트 B**의 MAC주소를 모른다면 한번 더 시도

      ![](<../../.gitbook/assets/image 16 (1).png>)

      * 이는 매우 간략화된 에시로, 실제로는 ARP만 사용하지는 않음(다음 장에 자세히 나옴)



📌 **ARP**는 **동일 네트워크에 속한 호스트의 MAC 주소를 알아내기 위해 사용하는 프로토콜**

📌 **다른 네트워크에 속한 호스트에게 패킷을 보내야 할 경우, 네트워크 외부로 나가기 위한 장비**(라우터)**의 MAC 주소를 알아내어 패킷을 전송**

{% hint style="success" %}
### 참조 1. IP 단편화를 피하는 방법

IP 단편화는 **되도록 하지 않는 것이 좋음.** 데이터가 여러 패킷으로 쪼개지면 자연스레 전송해야 할 **패킷의 헤더들도 많아지고,** 이는 **불필요한 트래픽 증가와 대역폭 낭비로 이어질 수 있음.** 또한, 쪼개진 IP 패킷들을 **하나로 합치는 과정에서 발생하는 부하**도 **성능 저하를 야기.**

* **경로 MTU**
  * **호스트 A, B**가 처리할 수 있는 **MTU**가 아무리 커도, 라우터가 해당 **MTU**를 지원하지 않으면 IP 단편화를 해야함.
  * 따라서 단편화를 피하려면 I**P 단편화 없이 주고 받을 수 있는 최대 크기만큼 전송**해야 하고, **이 크기를 경로 MTU라 함.**
  *   다시 말해 IP 단편화를 피하는 방법은 경로 MTU만큼의 데이터를 전송하는 것.

      ![](<../../.gitbook/assets/image 17 (1).png>)
* **경로 MTU 발견**
  * **경로 MTU를 구하고 해당 크기만큼만 송수신하여 IP 단편화를 회피하는 기술**을 **경로 MTU 발견** 이라 함.
  * 오늘날 네트워크에서는 대부분 이를 지원하고, 처리 가능한 최대 MTU 크기도 대부분 균일하기 때문에 IP 단편화는 자주 수행되지 않음.

가령 어떤 호스트로부터 처리 불가능한 크기(MTU를 넘어선 크기)의 IP 패킷을 전달 받았는데 **DF 플래그**가 설정되어 있다면 **오류 메시지를 전달**하게 됨. 그럼 IP 패킷을 전달한 호스트는 **이 오류 메시지를 받지 않을 때까지 전달하는 데이터 크기를 점차 줄이게 되고,** **이렇게 서로의 경로 MTU를 알아가게 됨.**
{% endhint %}

***

### <mark style="color:blue;">03-2 IP 주소</mark>

하나의 IP 주소는 크게 **네트워크 주소(네트워크를 표현하는 부분)**&#xC640; **호스트 주소(호스트를 표현하는 부분)**&#xB85C; 이루어져 있음.

네트워크 주소는 **호스트가 속한 특정 네트워크를 식별**하고, 호스트 주소는 **네트워크 내에서 특정 호스트를 식별하는 역할**을 함.



#### ⭐ 네트워크 주소와 호스트 주소

**네트워크 주소(네트워크 ID, 네트워크 식별자)**

**호스트 주소(호스트 ID, 호스트 식별자)**

*   **주소의 형태**

    * 네트워크 주소가 16비트, 호스트 주소가 16비트인 IP 주소의 예시

    ![](<../../.gitbook/assets/image 18 (1).png>)

    *   IP 주소에서 네트워크 주소와 호스트 주소를 구분하는 범위는 유동적일 수 있음. (네모 한칸이 하나의 옥텟이며, 하나의 옥텟은 8비트)

        ![](<../../.gitbook/assets/image 19 (1).png>)

        ![](<../../.gitbook/assets/image 20 (1).png>)

        * 호스트 주소 공간을 크게 할당하면 할당되지 않은 다수의 IP주소가 낭비될 수 있음.
        * 호스트 주소 공간이 작을 경우 호스트가 사용할 IP주소가 부족해질 수 있음.
        * 이를 해결하기 위해 **IP 주소의 클래스**가 나옴.



#### ⭐ 클래스풀 주소 체계(Classful addressing)

* **클래스**
  * **네트워크 크기에 따라 IP주소를 분류하는 기준**
  * 필요한 호스트 IP 개수에 따라 **네트워크 크기를 가변적으로 조정**해 네트워크 주소와 호스트 주소를 구획
  *   클래스를 기반으로 IP주소를 관리하는 주소 체계를 **클래스풀 주소 체계(Classful addressing)**&#xB77C;고 한다.

      ![](<../../.gitbook/assets/image 21 (1).png>)

      ![](<../../.gitbook/assets/image 22 (1).png>)

📌 호스트 주소가 전부 0이면 네트워크 주소, 1이면 브로드캐스트를 위한 주소로 사용됨

![](<../../.gitbook/assets/image 23 (1).png>)



#### ‼️ 클래스리스 주소 체계(Classless addressing)

만일 300명의 직원이 사용할 컴퓨터들을 동일한 네트워크로 구성하고 싶을 때, 어쩔수 없이 B클래스를 사용하여야 한다.

그래서 클래스풀 주소 체계보다 더 유동적이고 정교하게 네트워크를 구획할 수 있는 **클래스리스 주소 체계(Classless addressing)**&#xAC00; 등장함.

클래스에 구애받지 않고 네트워크 영약을 나누어서 호스트에게 IP 주소 공간을 할당하는 방식.

* **서브넷 마스크(Subnet mask)**
  * **네트워크와 호스트를 구분 짓는 수단**으로 **서브넷 마스크**를 이용함
  * **네트워크 주소는 1, 호스트 주소는 0**으로 표기한 비트열
  *   IP주소와 서브넷 마스크 간에 **AND연산**을 수행하여 네트워크 주소를 구할 수 있음.

      ![](<../../.gitbook/assets/image 24 (1).png>)



* **서브넷 마스크 표기: CIDR(Classless Inter-Domain Routing notation) 표기법**
  *   **‘IP 주소/서브넷 마스크상의 1의 개수’** 형식으로 표기하는 방법

      ![](<../../.gitbook/assets/image 25 (1).png>)

      ![](<../../.gitbook/assets/image 26 (1).png>)



#### ⭐ 공인 IP 주소와 사설 IP 주소

IP주소는 **고유한 IP 주소**가 있고, **고유하지 않은 IP 주소**도 있음

*   **공인 IP 주소**

    * 전 세계에서 **고유한 IP 주소**


*   **사설 IP 주소와 NAT**

    ![](<../../.gitbook/assets/image 27 (1).png>)

    * **사설 IP 주소**
      * **사설 네트워크**에서 사용하기 위한 IP 주소
      * 사설 네트워크란, 인터넷, 외부 네트워크에 공개되지 않은 네트워크
    *   **NAT(Network Address Translation)**

        * **IP주소를 변환하는 기술**(사설 IP 주소 ↔ 공인 IP부소)
        * (4장에서 자세히 다룰 예정!)



#### ⭐ 정적 IP 주소와 동적 IP 주소

**호스트에 IP주소를 할당하는 방식**에는 **정적 할당**과 **동적 할당**이 있다.

✅ **정적 할당**

* 호스트에 수작업으로 IP주소를 부여하는 방식(정적 IP 주소)

{% hint style="success" %}
#### **게이트웨이(gateway)**

* 서로 다은 네트워크를 연결하는 하드웨어적/소프트웨어적 수단
* **기본 게이트웨이(default gateway)**&#xB294; **네트워크 외부로 나가기 위한 기본적인 첫 경로**(첫 번째 홉)를 의미함
{% endhint %}



✅ **동적 할당과 DHCP**

*   **동적 할당**

    * 호스트에 IP 주소가 동적으로 할당되는 방식(동적 IP 주소)
    * 사용되지 않은 경우 회수되고, 할당받을 떄마다 다른 주소를 받을 수 있음


*   **DHCP(Dynamic Host Configuration Protocol)**

    * **IP주소를 할당받고자 하는** **호스트(클라이언트)와** 해당 호스트에게 **IP 주소를 제공하는 DHCP 서버**간에 메시지를 주고받음으로써 이루어짐
      * DHCP 서버의 역할은 일반적으로 라우터(공유기)가 수행하지만, 특정 호스트에 DHCP 서버 기능을 추가할 수도 있음.
      * DHCP 서버는 클라이언트에게 할당 가능한 IP 주소 목록을 관리하다가 클라이언트가 요청할 때 IP 주소를 할당함.
    * DHCP로 할당받은 IP 주소는 **사용할 기간이 정해져 있음**
      * 일반적으로 수 시간에서 수일로 설정
      * 그래서 **‘IP 주소를 임대한다’**&#xB77C;고 표현하기도함
      * **임대 갱신**
        * IP 주소의 임대 기간이 끝나기 전에 임대 기간을 연장하는것.
        * 기본적으로 두 차례 자동으로 수행됨
    *   IP주소를 할당받는 과정에서 클라이언트와 DHCP 서버 간에 주고받는 메시지의 종류는 크게 네 가지가 있음. **1\~4번 순**이며, DHCP 패킷을 주고받는 것과도 같음.

        1️⃣ **DHCP Discover**

        2️⃣ **DHCP Offer**

        3️⃣ **DHCP Request**

        4️⃣ **DHCP Acknowledgement(이하 DHCP ACK)**

        ![](<../../.gitbook/assets/image 28 (1).png>)

    1️⃣ **DHCP DIscover**

    * 클라이언트는 DHCP Discover 메시지를 통해 **DHCP 서버를 찾음.**
    * 브로드캐스트로 전송됨



    2️⃣ **DHCP Offer**

    * DHCP 서버는 **DHCP Discover 메시지를 받은 뒤** 클라이언트에게 **DHCP Offer 메시지를 보냄**
    * IP주소, 서브넷 마스크, 임대 기간 등의 정보도 포함되어 있음



    3️⃣ **DHCP Request**

    * **DHCP Offer 메시지에 대한 응답**으로, 이 IP주소를 써도 되냐고 묻는것과 같음.
    * 브로드캐스트로 전송됨



    4️⃣ **DHCP Acknowledgement(이하 DHCP ACK)**

    * 마지막으로 DHCP 서버는 클라이언트에게 DHCP ACK 메시지를 보냄.
    * **최종 승인**과도 같은 메시지임.



{% hint style="success" %}
#### 참조 1. 예약 주소: 0.0.0.0 vs 127.0.0.1

* **루프백 주소**
  * 자기 자신을 가리키는 특별한 주소
  * 가장 많이 사용되는 주소는 **127.0.0.1**이고, **로컬호스트**라고도 부름
* **0.0.0.0/8**
  * 이 네트워크의 이 호스트를 지칭
  * 호스트가 IP 주소를 할당받기 전에 임시로 사용하는 경우가 많음
* **0.0.0.0/0**
  * 모든 임의의 IP 주소
  * **디폴트 라우트**를 나타내기 위해 사용
  * **디폴트 라우트(default route)**
    * 패킷을 어떤 IP 주소로 전달할지 결정하기 어려울 경우 **기본적으로 패킷을 전달할 경로**를 의미.
    * (다음 절에서 자세히 설명\~)&#x20;
{% endhint %}

***

### <mark style="color:blue;">03-3 라우팅</mark>

**라우팅 테이블**이 만들어지는 방법과 프로토콜에 따라 라우팅을 분류한 그림

![](<../../.gitbook/assets/image 35 (1).png>)



#### ⭐ 라우터

멀리 떨어져 있는 호스트 간의 통신 과정에서 패킷은 서로에게 도달하기까지 여러 라우터를 거쳐서 다양한 경로로 이동할 수 있음.

* **홉(hop)**
  *   패킷이 호스트와 라우터 간에, 혹은 라우터와 라우터간에 이동하는 하나의 과정을 **홉**이라 함.

      ![](<../../.gitbook/assets/image 30 (1).png>)



#### ⭐ 라우팅 테이블

특정 수신지까지 도달하기 위한 정보를 명시한 일종의 표와 같은 정보.

*   라우팅 테이블의 공통적이고 핵심적인 정보

    ![](<../../.gitbook/assets/image 31 (1).png>)

    * **수신지 IP 주소와 서브넷 마스크**
      * 최종적으로 패킷을 전달할 대상
    * **다음 홉(next hop)**
      * 최종 수신지까지 가기 위해 다음으로 거쳐야 할 호스트의 IP 주소나 인터페이스
      * **게이트웨이**라고 명시되기도 함.
    * **네트워크 인터페이스**
      * 패킷을 내보낼 통로.
      * 인터페이스(NIC) 이름이 직접적으로 명시되거나 인터페이스에 대응하는 IP 주소가 명시되기도 함.
    *   **메트릭(Metric)**

        * 해당 경로로 이동하는 데에 드는 비용
        * 라우터가 라우팅 테이블에 있는 경로 중 패킷을 내보낼 경로를 선탤할 때 메트릭이 낮은 경로를 선호함.


* **디폴트 라우트**
  * 라우팅 테이블에 없을경우 기본적으로 패킷을 내보낼 경로
  *   0.0.0.0/0로 명시

      ![](<../../.gitbook/assets/image 32 (1).png>)

      ![](<../../.gitbook/assets/image 33 (1).png>)



#### ⭐ 정적 라우팅과 동적 라우팅

*   **정적 라우팅**

    * 수동으로 채워진 라우팅 테이블을 토대로 라우팅되는 방식
    * 네트워크 규모가 커지면 **관리가 힘들고**, **실수가 발생할 수 있음.** 또한, 라우팅 되는 경로상에 예상치 못한 문제가 생길때 **우회가 불가능함.**


*   **동적 라우팅**

    * **라우팅 프로토콜**을 통해 자동으로 채워진 라우팅 테이블 항목을 토대로 라우팅되는 방식
    * 동적 라우팅을 하면 라우팅 테이블 항목이 수시로 변할 수 있음.


* **AS(Autonomous System)**
  * 동일한 라우팅 정책으로 운용되는 라우터들의 집단
  *   AS외부와 통실할 경우 AS 내외로 통신을 주고받을 수 있는 **AS 경계 라우터(ASBR: AS Boundary Router)**&#xB77C;는 특별한 라우터를 이용함.

      ![](<../../.gitbook/assets/image 34 (1).png>)

#### ⭐ 라우팅 프로토콜

* **라우팅 프로토콜(routing protocol)**
  * 라우터끼리 자신들의 정보를 교환하며 패킷이 이동할 최적의 경로를 찾기 위한 프로토콜.
  * **AS내부**에서 수행되느냐, **외부**에서 수행되느냐에 따라 종류가 나뉨
  * 전자를 **IGP(Internet Gateway Protocol)**, 후자를 **EGP(Exterior Gateway Protocol)**&#xB77C;고 함
  *   **IGP**에는 **RIP**과 **OSPF**가 있고, **EGP**로는 **BGP**가 있음

      ![](<../../.gitbook/assets/image 35 (1).png>)



*   **IGP: RIP와 OSPF**

    ![](<../../.gitbook/assets/image 36 (1).png>)

    *   **RIP(Routing Information Protocol)**

        ![](<../../.gitbook/assets/image 37 (1).png>)

        * **거리 벡터**기반의 라우팅 프로토콜
        * **인접한 라우터끼리 경로 정보를 주기적으로 교환하여 라우팅 테이블을 갱신**
        * **거리를 기반**으로 최적의 경로를 찾는 라우팅 프로토콜
          * **거리**는 패킷이 경유한 라우터의 수, 즉 **홉의 수**를 의미함
          * **홉 수가 가장 적은 경로를 최적의 경로로 판단**하고, 홉 수가 적을수록 라우팅 테이블상의 메트릭 값도 작아짐
    *   **OSPF(Open Shortest Path First)**

        ![](<../../.gitbook/assets/image 38 (1).png>)

        * **링크 상태**가 사용됨
        * **네트워크의 구성이 변경되었을 때 라우팅 테이블이 갱신**
        * **현재 네트워크 상태를 그래프의 형태**로 **링크 상태 데이터베이스(LSDB: Link State DataBase)에 저장**함
          * 라우터들의 연결 관계, 연결 비용 등 현재 네트워크의 상태를 그래프로 표현하기 위한 데이터가 저장되어 있음
          * LSDB를 기반으로 현재 네트워크 구성을 마치 지도처럼 그린 뒤에 최적의 경로를 선택
        * 대역폭을 기반으로 메트릭을 계산
          * 대역폭이 높은 링크일수록 메트릭이 낮은 경로로 인식
        * 네트워크 구성이 변경될 때마다 라우팅 테이블이 갱신되면, 네트워크의 규모가 매우 커졌을때는 모든 정보를 저장하기 어려움.
          * 이에 OSPF에서는 AS를 area라는 단위로 나누고, 구분된 area내에서만 링크 상태를 공유
          *   area경계에 있는 ABR(Area Border Router)이라는 라우터가 area간의 연결을 담당함

              ![](<../../.gitbook/assets/image 39 (1).png>)

📌 **고급 거리 벡터 프로토콜과 링크 상태 프로토콜의 성격을 모두 띠는 라우팅 프로토콜도 있음.**

이를 **고급 거리 벡터 라우팅 프로토콜** 혹은 **하이브리드 라우팅** **프로토콜**이라고도 부름. 대표적으로 **EIGRP(Enhanced Interior Gateway Routing Protocol)**&#xAC00; 있음

* **EGP: BGP**
  * **BGP(Border Gateway Protocol)**
    * AS간의 통신에서 사용되는 대표적인 프로토콜로, 엄밀하게는 AS 간의 통신이 ‘가능한’ 프로토콜. AS 내 라우터 간 통신도 가능.
      * **AS간의 통신**을 위한 BGP는 **eBGP(external BGP),** **AS내의 통신**을 위한 BGP는 **iBGP(internal BGP)**&#xB77C;도고 함.
    * BGP 메시지를 주고받을 수 있도록 연결된 BGP라우터를 **피어(peer)**&#xB77C;고 정의함
      * 다른 AS와의 BGP연결을 유지하기 위해서는 BGP라우터끼리 연걸되어 피어가 되어야 함.
      *   이 과정을 **피어링(peering)**&#xC774;라 함.

          ![](<../../.gitbook/assets/image 40 (1).png>)
    *   BGP의 속성이란 경로에 대한 일종의 부가 정보로, 대표적으로 **AS-PATH, NEXT-HOP, LOCAL-PREF**가 있음(한번 훑어보고 넘어가기!)

        ![](<../../.gitbook/assets/image 41 (1).png>)

        ![](<../../.gitbook/assets/image 42 (1).png>)

        * **AS-PATH**
          * **메시지가 수신지에 이르는 과정에서 통과하는 AS들의 목록**
        * **NEXT-HOP**
          * **다음으로 거칠 라우터의 IP주소**를 나타냄.
          * AS1에서 곧장 AS2로 가는 경로의 NEXT-HOP은 AS1과 연결된 라우터 a의 IP주소.
        * **LOCAL-PREF(LOCAL PREFerence)**
          * AS외부 경로에 있어 **AS 내부에서 어떤 경로를 선호할지에 대한 척도를 나타내는 속성**
          * **‘정책적인 이유로 이 경로를 우선시하겠다’, ‘설령 이 경로가 다른 경로에 비해 비교적 비효율적이라도 이 경로를 우선시 하겠다’**&#xB77C;는 말과 같음.

***

