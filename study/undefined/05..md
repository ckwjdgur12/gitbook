# 05. 응용 계층

### <mark style="color:blue;">05-1 DNS와 자원</mark>

#### ⭐ 도메인 네임과 네임 서버(DNS 서버)

* **도메인 네임**
  *   호스트의 IP 주소와 대응되는 문자열 형태의 호스트 특정 정보

      * ex) [www.example.com](http://www.example.com)


* **네임 서버(DNS 서버)**
  * 도메인 네임과 IP 주소를 관리하는 서버
  *   IP 주소가 바뀌더라도 바뀐 IP 주소에 도메인 네임을 다시 대응하는 방식으로 간편함.

      ![](<../../.gitbook/assets/image (5).png>)

{% hint style="success" %}
**hosts 파일**

호스트마다 유지하는 ‘개인’ 전화번호부 같은 파일.
{% endhint %}



*   **도메인 네임 구조**

    * 점(.)을 기준으로 계층적으로 분류됨
    *   최상단에 **루트 도메인**, 그 다음 단계인 **최상위 도메인(TLD: Top-Level Domain)**&#xC774; 있으며, 계속 그다음 단계의 도메인이 있음.

        ![image.png](<../../.gitbook/assets/image 1 (5).png>)
    * 루트 도메인도 도메인 네임의 일부이지만 생갹해서 표기하기에 대개**최상위 도메인**을 **‘도메인 네임의 마지막 부분’**&#xC73C;로 간주.
      * ex) [www.google.com](http://www.google.com)**. ←** 마지막에 점!!
    * **2단계 도메인**
      * 최상위 도메인의 하부 도메인 → www.example.com의 example에 해당함
    * **3단계 도메인** → www에 해당함
    * 이보다 더 늘어날 수 있지만 일반적으로는 3\~5단계
    *   **도메인 네임을 모두 포함하는 도메인 네임**을 **전체 주소 도메인 네임(FQDN: Fully-Qulified Domain Name)**&#xC774;라 함.

        ![](<../../.gitbook/assets/image 2 (5).png>)
    * **FQDN의 첫 번째 부분까지 고려한 도메인 네임**은 하나밖에 없으므로, **호스트를 식별할 수 있는 도메인 네임을 얻을 수 있음.**
      * 이런 점에서 **FQDN의 첫 번째 부분(www)을** **호스트 네임(host name)이라 부르기도 함.**
        * ‘호스트 네임’이라는 용어는 FQDN 자체를 가리키기도 하며, 네트워크상의 장치 자체의 이름을 가리키기도 함.
    * 이렇게 **계층적이고, 분산된 도메인 네임에 대한 관리 체계**를 **도메인 네임 시스템(DNS)**&#xC774;라 부름



{% hint style="success" %}
💡**서브 도메인**

다른 도메인이 포함된 도메인을 의미함

google.com의 서브 도메인

* [mail.google.com](http://mail.google.com)
* [www.google.com](http://www.google.com)
{% endhint %}



#### ⭐ 계층적 네임 서버

IP주소를 모르는 상태에서 도메인 네임에 대응되는 IP 주소를 알아내는 과정을 **도메인 네임을 풀이(resolve) 한다**라고 표현하며, 영어로는 **리졸빙한다(resolving)**&#xB77C;고도 표현함.

*   **계층적 네임 서버**

    ![](<../../.gitbook/assets/image 3 (5).png>)

    * **로컬 네임 서버(Local name server)**
      * 클라이언트가 도메인 네임을 통해 IP 주소를 알아내고자 할 때 가장 먼저 찾게 되는 네임 서버
      * 일반적으로 ISP에서 할당해 주는 경우가 많음.
      * **공개 DNS 서버**를 이용할 수도 있음.
        * 구글의 8.8.8.8, 8.8.4.4, 클라우드플레어의 1.1.1.1
    * **루트 네임 서버**
      * 로컬 네임 서버가 대응되는 IP 주소를 모를 경우 루트 네임 서버에게 해당 도메인 네임을 질의.
      *   루트 도메인을 관장하는 네임 서버로, 질의에 대해 TLD(Top-Level Domain) 네임 서버의 IP주소를 반환할 수 있음.

          ![](<../../.gitbook/assets/image 4 (5).png>)
    * **TLD 네임 서버**
      * TLD를 관리하는 네임 서버
    * **책임 네임 서버(Authoritative name server)**
      * 자신이 관리하는 도메인 영역의 질의에 대해서는 **다른 네임 서버에게 떠넘기지 않고 곧바로 답할 수 있는 네임 서버**
      *   로컬 네임 서버가 마지막으로 질의하는 네임 서버

          * 여기로 부터 원하는 IP주소를 얻어냄.


* **질의 방식**
  *   **재귀적 질의**

      ![](<../../.gitbook/assets/image 5 (5).png>)
  *   **반복적 질의**

      ![](<../../.gitbook/assets/image 6 (5).png>)



* **DNS 캐시**
  * 하나의 도메인 네임을 리졸빙하기 위해 8개의 단계를 거쳐야 하는 것 처럼 **시간이 오래 걸리고 네트워크상의 메시지 수가 지나치게 늘어날 수 있음.**
  * 기존에 응답받은 결과를 임시로 저장했다가 추후 같은 질의에 이를 활용하기 위해 **DNS 캐시**를 사용
  * DNS 캐시를 저장하는 용도로만 사용되는 서버도 있음.
  * **더 짧은 시간 안에 원하는 IP주소를 얻어낼 수 있음**
  * TTL(Time To Live)이라는 값과 함께 저장되며, 이 시간이 지나면 사라짐.



#### ⭐ 자원을 식별하는 URI

*   **자원(Resource)**

    * **네트워크상의 메시지를 통해 주고받는 대상**
    * HTML, 이미지나 동영상, 텍스트 파일이 될 수 있음
    * ‘**HTTP 요청 메시지의 대상’** 이라고도 표현함.


* **URI(Uniform Resource Identifier)**
  * 자원을 식별할 수 있는 정보, 자원을 식별하는 통일된 방식
  * **URL**
    *   **scheme, authority, path, query, fragment의 다섯 가지로 구성됨**

        ![](<../../.gitbook/assets/image 7 (3).png>)

        * **scheme**
          * **자원에 접근하는 방법**
          * 일반적으로 사용할 프로토콜이 명시됨
          * HTTP를 사용하여 자원에 접근할 때는 [http://를](http://xn--bx2b) 사용
        * **authority**
          * **호스트를 즉정할 수 있는 정보**
          * IP주소 혹은 도메인 네임이 명시됨
        * **path**
          * **자원이 위치한 경로**
        * **query**
          * 위치 이외에 더 많은 정보가 필요할 때 사용함.
          * **쿼리 문자열(query string)**
            * **쿼리 파라미터(query parameter)**&#xB77C;고도 부름.
            *   **(?)**&#xB85C; 시작되는 **<키=값>** 형태의 데이터로, **(&)**&#xB97C; 사용하여 여러 문자열을 연결할 수 있음

                ![](<../../.gitbook/assets/image 8 (3).png>)
        * **fragment**
          * **자원의 한 조각을 가리키기 위한 정보**
          * HTML파일과 같은 자원에서 **특정 부분을 가리키기 위해 사용됨**
            * fragment 미포함 - HTML의 첫 부분이 보임
              * [https://datatracker.ietf.org/doc/html/rfc3986](https://datatracker.ietf.org/doc/html/rfc3986)
            * fragment 포함 - HTML파일의 **특정 부분으로 이동하여 보임**
              * [https://datatracker.ietf.org/doc/html/rfc3986#section-1.1.2](https://datatracker.ietf.org/doc/html/rfc3986#section-1.1.2)
  *   **URN**

      * 자원에 고유한 이름을 붙이는 이름 기반 식별자
        * ex) urn:isbn:0451450523
      * 위치나 프로토콜과 무관하게 자원을 식별할 수 있음



📌 **URI로는 URN보다 URL이 더 많이 사용됨**



{% hint style="success" %}
#### 💡참조 1. DNS 레코드 타입

네임 서버는 DNS 자원 레코드라 불리는 정보를 저장하고 관리함.

example.com이라는 도메인을 1.2.3.4에 대응시키고자 한다면 **네임 서버에게 알리기 위해 도메인 레코드를 추가해야함.**

**타입(Record Type), 이름(Record name), 값(value), TTL**이 있음

<img src="../../.gitbook/assets/image 9 (3).png" alt="" data-size="original">

<img src="../../.gitbook/assets/image 10 (3).png" alt="" data-size="original">

첫째 줄 레코드를 보면 example.com.이 1.2.3.4에 대응되어 있다는 것을 보여줌.

둘째 줄 레코드를 보면 example.com.에 대한 별칭으로 www.example.com.을 사용하겠다는 것을 보여줌.
{% endhint %}

***

### <mark style="color:blue;">05-2 HTTP</mark>

#### ⭐ HTTP의 특성

*   **HTTP**

    * **응용 계층에서 정보를 주고받는 데 사용되는 프로토콜.**


*   **요청-응답 기반 프로토콜**

    * HTTP는 클라이언트-서버 구조 기반의 요청-응답 프로토콜
    * 같은 HTTP 메시지일지라도 HTTP 요청 메시지와 응답 메시지 형태가 다름


* **미디어 독립적 프로토콜**
  * HTTP는 **자원의 특성을 제한하지 않으며,** **단지 자원과 상호 작용하는 데 사용할 수 있는 인터페이스를 정의**할 뿐임. 대부분의 자원은 URI로 식별됨.
  * 자원의 종류를 **미디어 타입(media type)**, 또는 **MINE 타입(Multipurpose Internet Mail Extention Type)**&#xC774;라고 부름.
  * 미디어 타입은 기본적으로 **type/subtype형식**으로 구성됨
    * ex) text/plain, application/json, multipart/form-data
  *   부가적인 설명을 위해 매개변수가 포함될 수도 있음.

      * 매개변수는 **‘type/subtype;매개변수=값’** 형식으로 표현됨.
      * ex) type/html;charset=UTF-8


*   **스테이트리스 프로토콜**

    * HTTP는 상태를 유지하지 않음
    * 모든 클라이언트의 상태 정보를 유지하는 것은 서버에 큰 부담임.
    * 상태를 유지하지 않는 stateless한 특성은 필요하다면 언제든 쉽게 서버를 추가할 수 있기 때문에 **확장성이 높고,** 서버 중 하나에 문제가 생겨도 쉽게 다른 서버로 대체가 가능하기 때문에 **견고성이 높음.**


* **지속 연결 프로토콜**
  * **비지속 연결**
    * 초기 HTTP 버전(1.0이하)는 TCP연결을 수립 후 요청에 대한 응답을 받으면 종료하는 방식으로 동작했으며, 추가적인 요청-응답을 하기 위해서는 다시 TCP를 수립해야 했음. 이러한 방식을 **비지속 연결**이라 함.
  * **지속 연결**
    *   최근 HTTP 버전(1.1이상)을 **지속 연결(Persistent connection)**&#xC744; 제공하고, **Keep-alive**라 부르기도 함. 비지속 연결에 비해 더 빠르게 여러 HTTP 요청과 응답을 처리할 수 있음

        ![](<../../.gitbook/assets/image 11 (3).png>)



#### ⭐ HTTP 메시지 구조

* **HTTP 메시지 구조**
  *   **시작 라인, 필드 라인, 메시지 본문**으로 이루어져 있음.

      ![](<../../.gitbook/assets/image 12 (3).png>)



* **시작 라인**
  * **요청 메시지**인 경우 **요청 라인**, **응답 메시지**인 경우 **상태 라인**이 되고, 모두 공백으로 구분됨.
    * **요청 라인**
      * **메서드(method)**
        * 클라이언트가 서버의 자원에 대해 **수행할 작업의 종류**를 나타냄
        * GET, POST, PUT, DELETE등이 있음
      * **요청 대상(request-target)**
        * **HTTP 요청을 보낼 서버의 자원**을 의미함.
        * “[http://www.example.com/hello?q=world”로](http://www.example.com/hello?q=world%E2%80%9D%EB%A1%9C) 보낼 경우, 요청 대상은 “/hello?q=world”가 됨
        * 하위 경로가 없더라도 요청 대상은 “/”가 됨.
      * **HTTP 버전(HTTP-version)**
        * HTTP 버전 1.1은 HTTP/1.1로 표기됨
    *   **상태 라인**

        * **HTTP 버전**
        * **상태 코드(status code)**
          * 요청에 대한 결과를 나타내는 세 자리 정수
        * **이유 구문(reason phrase)**
          * 상태 코드에 대한 문자열 형태의 설명
        * ex) HTTP/1.1 404 Not Found


* **필드 라인**
  * **0개 이상의 HTTP 헤더**가 명시됨. **헤더 라인**이라고도 불림.
  * **HTTP 헤더**
    * HTTP 통신에 필요한 부가 정보
  *   각 HTTP 헤더는 콜론(:)을 기준으로 헤더 이름과 하나 이상의 헤더값으로 구성

      ![](<../../.gitbook/assets/image 13 (3).png>)



* **메시지 본문**
  *   존재하지 않을 수도 있고, 다양한 콘텐츠 타입이 사용될 수도 있음

      ![](<../../.gitbook/assets/image 14 (3).png>)



#### ⭐ HTTP 메서드

![](<../../.gitbook/assets/image 15 (3).png>)

* **GET - 가져다주세요**
  * **특정 자원을 조회할 때 사용되는 메서드**
  * 요청 라인의 ‘요청 대상’, ‘Host 헤더’가 사용됨
  *   GET 메서드에 요청 메시지 본문을 포함시키는 것은 바람직 하지 않고, 쿼리 문자열을 사용하는 경우가 많음.

      ![](<../../.gitbook/assets/image 16 (2).png>)
  *   성공적으로 처리되었다면 응답으로서 요청한 자원을 전달받게 됨

      ![](<../../.gitbook/assets/image 17 (2).png>)



*   **HEAD - 헤더만 가져다주세요**

    * 사실상 **GET**과 동일한 역할을 하지만, 응답으로 **메시지 본문 없이 헤더만 포함**


* **POST - 처리해 주세요**
  *   서버로 하여금 특정 작업을 처리하도록 요청하는 메서드

      ![](<../../.gitbook/assets/image 18 (2).png>)
  *   성공적으로 처리되면 Location헤더를 통해 새로 생성된 자원의 위치를 클라이언트에게 알려줄 수 있음.

      ![](<../../.gitbook/assets/image 19 (2).png>)



* **PUT - 덮어써 주세요**
  * **덮어쓰기를 요청하는 메서드**
  * **요청 자원이 없다면** 메시지 본문으로 **자원을 새롭게 생성**하거나, **이미 자원이 존재한다면** 메시지 본문으로 **자원을 완전히 대체**하는 메서드



* **PATCH - 일부 수정해 주세요**
  * **부분적으로 수정**
  *   **요청**

      ![](<../../.gitbook/assets/image 20 (2).png>)
  *   **PUT 결과**

      ![](<../../.gitbook/assets/image 21 (2).png>)
  *   **PATCH 결과**

      ![](<../../.gitbook/assets/image 22 (2).png>)
*   **DELETE - 삭제해 주세요**

    * **특정 자원을 삭제**하고 싶을 때 사용하는 메서드



{% hint style="success" %}
💡**API 문서**

어떤 URL로 어떤 요청을 받았을 때 **서버가 어떻게 동작할지에 대해 보여주는 문서**&#x20;
{% endhint %}



#### ⭐ HTTP 상태 코드

* **상태 코드**
  *   **요청에 대한 결과를 나타내는 세 자리 정수**

      ![](<../../.gitbook/assets/image 23 (2).png>)
*   **200번대: 성공 상태 코드**

    *   **‘요청이 성공했음’**&#xC744; 의미함

        ![](<../../.gitbook/assets/image 24 (2).png>)
    * 작업 시간이 긴 대용량 파일 업로드 작업이나 배치 작업과 같이 **요청 결과를 곧바로 응답하기 어려운 상황인 경우** **202(Accepted)**&#xB85C; 응답할 수 있음.


* **300번대: 리다이렉션 상태 코드**
  * **리다이렉션**과 관련된 상태 코드
  * **리다이렉션(redirection)**
    * **요청을 완수하기 위해 추가적인 조치가 필요한 상태**
    * 클라이언트가 **요청한 자원이 다른 곳에 있을 때**, 클라이언트의 요청을 **다른 곳으로 이동**시키는 것.
      * 위 경우, 서버는 응답 메시지의 **Location 헤더**를 통해 **요청한 자원이 있는 URL을 안내**해줌
      *   이를 수신한 클라이언트는 **Location 헤더에 명시된 URL로 즉시 재요청**을 보내어 **새로운 URL에 대한 응답을 받음**

          ![](<../../.gitbook/assets/image 25 (2).png>)
  * **영구적인 리다이렉션(permanent redirection)**
    *   자원이 완전히 새로운 곳으로 이동하여 경로가 영구적으로 재지정되는 것

        ![](<../../.gitbook/assets/image 26 (2).png>)
    *   클라이언트가 서버에 POST 메서드와 같이 GET 메서드가 아닌 요청을 보냈고, **301(Moved Permanently)**&#xC751;답 메시지를 받았을 때, 두 번째 요청 메서드는 **GET으로 바뀔 ‘수도’있음.**

        ![](<../../.gitbook/assets/image 27 (2).png>)
    *   이런 애매함으로 인해 등장한 상태 코드가 **308(Permanent Redirect)**&#xC784;. 두 번째 요청에서 메서드가 변경되지 않음.

        ![](<../../.gitbook/assets/image 28 (2).png>)
  * **일시적인 리다이렉션(Temporary redirection)**
    *   자원의 위치가 임시로 변경되었거나 임시로 사용할 URL이 필요한 경우에 사용됨.

        ![](<../../.gitbook/assets/image 29 (2).png>)
    * 301과 302, 307과 308은 역할이 같고, 임시적인지, 영구적인지에 대한 차이만 있음.
    *   **303(See Other)**&#xC740; 두번째 요청 메서드를 GET으로 바꿔 주기 위해 사용됨

        ![](<../../.gitbook/assets/image 30 (2).png>)
  *   여기서 말하는 **‘다른 곳’**&#xC740; **다른 URL**이 될 수도 있고, **캐시**가 될 수도 있음(다음절에 나옴!)

      * **304(Not Modified)**&#xB294; **‘자원이 변경되지 않았음’**&#xC744; 의미하는 상태 코드이며, **캐시와 관련있음.**


*   **400번대: 클라이언트 에러 상태 코드**

    *   **클라이언트에 의한 에러가 있음**을 알려 주는 상태 코드

        ![](<../../.gitbook/assets/image 31 (2).png>)
    * **401(Unauthorized)**&#xB85C; 응답할 때는 반드시 **WWW-Authenticate**라는 헤더를 통해 **인증 방법을 알려주어야 함.**
    * **404(Not Found)**&#xB294; 존재하더라도 공개하지 않는 자원에 대해 응답하는 경우도 있음



{% hint style="success" %}
- **인증**
  * **자신이 누구인지 증명하는 것**
- **인가**
  * **인증된 주체에게 작업을 허용하는 것**&#x20;
{% endhint %}



*   **500번대: 서버 에러 상태 코드**

    *   **서버 에러**에 대한 상태 코드

        ![](<../../.gitbook/assets/image 32 (2).png>)
    * **502(Bad Gateway)**&#xB294; **클라이언트와 서버 사이에 위치한 중간 서버의 통신 오류**를 나타내는 상태 코드
    *   클라이언트와 서버는 일반적으로 **일대일로 연결되어 통신하지 않고,** 게이트웨이를 비롯한 **여러 중간 서버가 존재할 수 있음.** (중간 서버와 관련된 자세한 내용은 07-1의 좀 더 알아보기!)

        ![image.png](<../../.gitbook/assets/image 33 (2).png>)
    * **503(Service Unavailable)**&#xC740; **‘현재 서비스를 일시적으로 이용할 수 없음’**&#xC744; 의미하며, **서버가 과부하 상태에 있거나 일시적인 점검 상태일 때** 볼 수 있는 상태 코드.



{% hint style="success" %}
#### 💡참조 1. HTTP의 발전: HTTP/0.9에서 HTTP/3.0까지

*   **HTTP/0.9**

    * 지금은 거의 사용되지 않는 초창기 HTTP 버전
    * **사용 가능한 메서드가 GET 뿐**이었음


*   **HTTP/1.0**

    * **HEAD, POST와 같은 GET 이외의 메서드가 도입** 되었고, **헤더가 지원**되기 시작해 훨씬 더 다양한 정보를 주고받을 수 있게 되었음.
    * **지속적 연결(persistent connection)을 지원하지 않음**


*   **HTTP/1.1**

    * **지속 연결을 지원**
    * **파이프라이닝 기능**과 **콘텐츠 협상** **기능** 등 다양한 편의 기능 및 사용 가능한 헤더가 추가


* **HTTP/2.0**
  * **HTTP/1.1의 효율과 성능을 높이기 위한 버전**으로, HTTP/1.1을 보완하고 개선하기 위한 버전
  * **데이터를 압축하여 전송**하고, **바이너리 데이터 기반의 메시지를 송수신**함.
  *   클라이언트가 요청하지 않았더라도 미래에 필요할 것으로 예상되는 자원을 미리 전송해 주는 **서버 푸시(server push)라는 기능을 제공**하기도 함.

      ![](<../../.gitbook/assets/image 34 (2).png>)
  * HTTP/1.1까지의 고질적인 문제였던 **HOL 블로킹(Head-Of-Line blocking)문제를 완화**
    *   **HOL 블로킹**이란 같은 큐에 대기하며 순차적으로 처리되는 여러 패킷이 있을 때, **첫 번째 패킷의 처리 지연으로 인해 나머지 패킷들의 처리도 모두 지연되는 문제** 상황

        ![](<../../.gitbook/assets/image 35 (2).png>)
    *   **멀티플렉싱(multiplexing)**&#xAE30;법을 도입해서 완화

        * **HTTP 멀티플렉싱**이란 여러 스트림을 이용해 병렬적으로 메시지를 주고받는 기술
        * **요청과 응답을 주고 받는 단위는 하나의 스트림**에서 이루어지고, **이러한 스트림을 여러 개 활용**하는 동시에 **스트림별로 독립적인 송수신이 가능**하며, **스트림별 메시지들은 꼭 일정한 순서를 유지할 필요가 없음.**
        * **별도의 스트림을 통해 여러 데이터를 병렬적으로 주고받는다면 HOL 블로킹을 상당 부분 완화**할 수 있음.


* **HTTP/3.0**
  * **UDP를 기반으로 동작**
    * UDP를 기반으로 구현된 **QUIC(Quick UDP Internet Connection)프로토콜**을 기반으로 동작
    * TCP에 비해 UDP는 상대적으로 더 빠르기 때문에 **속도 측면에서 큰 개선이 이루어 짐**
    * **현재 빠르게 성장하는 프로토콜로, 이에 따라 QUIC의 중요성도 점차 커지고 있음.**&#x20;
{% endhint %}

***

### <mark style="color:blue;">05-3 HTTP 헤더와 HTTP 기반 기술</mark>

#### ⭐  HTTP 헤더

* **요청 시 활용되는 HTTP 헤더**
  * **Host**
    *   요청을 보낼 호스트를 나타내는 헤더.

        ![](<../../.gitbook/assets/image 36 (2).png>)
  * **User-Agent**
    * HTTP 요청을 시작하는 클라이언트 측의 프로그램
    *   서버 입장에서는 이것을 보고 클라이언트의 접속 환경을 유추할 수 있음.

        ![](<../../.gitbook/assets/image 37 (2).png>)
  * **Referer**
    * 클라이언트가 요청을 보낼 때 머무르고 있던 URL
    *   해당 URL에서 요청을 보냈음을 의미

        ![](<../../.gitbook/assets/image 38 (2).png>)
  * **Authorization**
    * 클라이언트의 인증 정보를 담는 헤더
    *   인증 타입\<type>과 인증 정보\<credentials>가 차례로 명시됨

        ![](<../../.gitbook/assets/image 39 (2).png>)
    *   가장 기본적인 HTTP 인증 타입은 **Basic**으로, username:password와 같이 사용자 아이디와 비밀번호를 콜론을 이용해 합친 뒤 Base64 인코딩한 값을 인증 정보로 삼는 방식

        ![](<../../.gitbook/assets/image 40 (2).png>)



* **응답 시 활용되는 HTTP 헤더**
  * **Server**
    * 요청을 처리하는 서버 측의 소프트웨어와 관련된 정보를 명시
    *   아래 예시는 ‘Unix 운영체제에서 동작하는 아파치 HTTP 서버’를 의

        ![](<../../.gitbook/assets/image 41 (2).png>)
  * **Allow**
    * 클라리언트에게 허용된 HTTP 메서드 목록을 알려 주기 위해 사용됨
    *   405(Method Not Allowed)와 함께 사용됨

        ![](<../../.gitbook/assets/image 42 (2).png>)
  * **Retry-After**
    * 503(Service Unavailable)과 함께 사용됨
    * 자원을 사용할 수 있는 날짜 혹은 시각을 나타냄.
    *   다음은 각각 ‘해당 날짜 이후’, ‘120초 이후에 사용 가능하다'는 사실을 나타냄.

        ![](<../../.gitbook/assets/image 43 (1).png>)
  * **Location**
    * 클라이언트에게 자원의 위치를 알려 주기 위해 사용됨.
    * Redirection이나 새로운 자원이 생성돼었을 때 사용됨.
  * **WWW-Authenticate**
    * 401(Unauthorized)와 함께 사용됨
    * 자원에 접근하기 위한 인증 방식을 설명하는 헤더.
    *   아래와 같이 Basic 인증을 요구할 수 있음.

        ![](<../../.gitbook/assets/image 44 (1).png>)
    *   실제로는 **보안영역(realm)**&#xACFC; **문자집합(charset)**&#xACFC; 같이 더 많은 정보를 알려주는 경우가 많음.

        ![](<../../.gitbook/assets/image 45 (1).png>)

        * **realm**은 보안이 적용될 영역을 의미함. 같은 서버가 제공하는 자원일지라도, 각 영역마다 자원 접근 권한이 다를 수 있음.
    *   아래는 인증되지 않은 클라이언트가 HTTP 인증을 수행하는 과정

        ![](<../../.gitbook/assets/image 46 (1).png>)



* **요청과 응답 모두에서 활용되는 HTTP 헤더**
  * Date
  * Connection
    *   HTTP의 특성인 keep-alive, close가 많이 쓰임

        ![](<../../.gitbook/assets/image 47 (1).png>)
  * Content-Length
  * Content-Type, Content-Language, Content-Encoding
    * Content-Encoding → 메시지 본문을 압축하거나 변환한 방식이 명시



#### ⭐ 캐시

**대역폭 낭비, 응답 지연을 방지**하기 위해 **사본**을 임시 저장하는 기술

항상 캐시한 이후 원본 데이터가 변경되는 상황에 대비해야 함.

캐시 신선도를 유지하기 위해 만료 날짜를 두고, 캐시가 여전히 유효한지 검사하기 위해 **날짜** 기반, **엔티티 태그** 기반으로 확인함.

![](<../../.gitbook/assets/image 48 (1).png>)



#### ⭐ 쿠키

서버에서 생성되어 클라이언트 측에 저장되는 데이터로, 상태를 유지하지 않는 HTTP의 특성을 보완하기 위한 수단.

사용 가능한 도메인이 정해져 있고, 경로를 명시할 수도 있음.

쿠키의 한계인 보안 문제를 해결하기 위해 **Secure**와 **HttpOnly**라는 속성이 있음.

* **Secure**
  * HTTPS 프로토콜이 사용되는 경우에만 쿠키를 전송되도록 하는 속성
* **HttpOnly**
  * 자바스크립트에서 쿠키에 접근하지 못하도록 하는 속성



#### ⭐ 콘텐츠 협상과 표현

* **표현 (representation)**
  * 송수신 가능한 자원의 형태
*   **콘텐츠 협상 (content negotiation)**

    * 같은 URI에 대해 가장 적합한 자원의 **표현**을 제공하는 메커니즘.



***
